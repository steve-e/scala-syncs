package syncs.catsintro

import cats.Functor
import org.scalatest.matchers.should.Matchers
import org.scalatest.wordspec.AnyWordSpec
import scala.languageFeature.higherKinds
// Using word spec for nesting
class CatsIntroTest extends AnyWordSpec with Matchers {

  "Functor" when {

    "not imported in this scope" should {
      "not be usable" in {
        """Functor[Option]""" shouldNot compile
      }
    }

    /* Summon a functor instance for Option with with Functor[Option]
    This uses the apply method on Functor, which simply returns its implicit argument. See
    https://github.com/typelevel/cats/blob/a982d333f5bec376d43ecc7f4427a08e40cf9f88/core/src/main/scala/cats/Functor.scala#L229
     */
    "summoned for Option" should {
      val someString: Some[String] = Some("hello some cats")
      val noneString: Option[String] = None
      // Imports added locally to show which is used where.
      import cats.implicits.catsStdInstancesForOption

      "map a function" in {
        Functor[Option].map(someString)(_.toUpperCase) shouldBe Some("HELLO SOME CATS")
        Functor[Option].map(noneString)(_.toUpperCase) shouldBe None
      }
    }

    "summoned for List" should {
      val strings: List[String] = List("hello", "cats")
      val noStrings: List[String] = List.empty

      import cats.implicits.catsStdInstancesForList
      "map a function" in {
        Functor[List].map(strings)(_.toUpperCase) shouldBe List("HELLO", "CATS")
        Functor[List].map(noStrings)(_.toUpperCase) shouldBe Nil
      }
    }

    "used in polymorphic methods" should {

      def uppercaseContentsWithImplicitEvidence[F[_]](func: F[String])(implicit ev: Functor[F]): F[String] = {
        ev.map(func)(_.toUpperCase)
        // or: Functor[F].map(func)(_.toUpperCase)
        // or:  implicitly[Functor[F]].map(func)(_.toUpperCase)
      }

      // implicit param is generated by the compiler, but we don't have its name.
      def uppercaseContentsWithContextBound[F[_] : Functor](func: F[String]): F[String] = {
        Functor[F].map(func)(_.toUpperCase)
      }

      "be parameterised" in {
        import cats.implicits._
        uppercaseContentsWithImplicitEvidence(List("upper", "case")) shouldBe List("UPPER", "CASE")
        val someString: Option[String] = Some("upper case")
        uppercaseContentsWithContextBound(someString) shouldBe Some("UPPER CASE")
      }
    }

    "syntax" should {
      import cats.implicits._


      "be available for map" in {
        def reverseStringContents[F[_] : Functor](func: F[String]): F[String] = {
          /*
           this map method is not declared on Functor, but on Functor.Ops, and is brought in implicitly
           */
          func.map(_.reverse)
        }



        // Pass the Option as a type parameter to the method
        reverseStringContents[Option](Some("live")) shouldBe "evil".some
        reverseStringContents[Option](None) shouldBe None
        // use cats syntax to create Option[String]
        reverseStringContents("live".some) shouldBe "evil".some
        reverseStringContents(none[String]) shouldBe None


        // Can use on any Functor implicitly available, eg Functor[List]
        reverseStringContents(List("one", "two")) shouldBe List("eno", "owt")

        // There is no Functor[Some] so this does not compile. Have to tell the compiles is is an Option[String]
        """reverseStringContents(Some("live")""" shouldNot compile
      }

      "be available for void" in {
        List(1, 2, 3).void shouldBe List((), (), ())

        Option("a value").void shouldBe Some(())
      }

      "be usable on my own Functor for my own class" in {
        case class Thing[T](definitely: T, maybe: Option[T])
        val thing1 = Thing("of course", None)
        val thing2 = Thing("always", Some("sometimes"))
        val thing3 = Thing(1, Some(2))

        implicit val thingFunctor: Functor[Thing] = new Functor[Thing] {
          override def map[A, B](fa: Thing[A])(f: A => B): Thing[B] = Thing(f(fa.definitely), fa.maybe.map(f))
        }

        thing1.map(_.toUpperCase) shouldBe Thing("OF COURSE", None)
        thing2.map(_.length) shouldBe Thing(6, Some(9))
        thing3.map(x => x * 3) shouldBe Thing(3, Some(6))

      }

    }
  }

  "Traversable" when {
    "not imported" should {
      "not be usable" in {
        "List(Some(1)).sequence" shouldNot compile
      }
    }
    "summoned" should {
      "allow sequencing" in {
        import cats.syntax.traverse._
        import cats.syntax.option._
        import cats.instances.list._
        import cats.instances.option._
        List(1.some, 5.some).sequence shouldBe Some(List(1, 5))
      }

      import cats.implicits._

      // We need a 1-kinded type, that is, with only one type param, so can't use Either directly
      type EitherString[T] = Either[String, T]

      def parseStringToInt(s: String): EitherString[Int] = Either.catchOnly[NumberFormatException](s.toInt).leftMap(_ => "failed to parse")

      "traverse a list with a function returning option, producing Some List if everything succeeds" in {

        // parse everything and get a Right of a List of parsed strings
        List("1", "5").traverse[EitherString, Int](parseStringToInt) shouldBe Right(List(1, 5))
      }

      "traverse a list with the same function, producing Left if anything fails" in {
        List("1", "Five").traverse(parseStringToInt) shouldBe Left("failed to parse")
      }

    }

  }

}
